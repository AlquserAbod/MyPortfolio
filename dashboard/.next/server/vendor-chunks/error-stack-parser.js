"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/error-stack-parser";
exports.ids = ["vendor-chunks/error-stack-parser"];
exports.modules = {

/***/ "(ssr)/./node_modules/error-stack-parser/error-stack-parser.js":
/*!***************************************************************!*\
  !*** ./node_modules/error-stack-parser/error-stack-parser.js ***!
  \***************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n(function(root, factory) {\n    \"use strict\";\n    // Universal Module Definition (UMD) to support AMD, CommonJS/Node.js, Rhino, and browsers.\n    /* istanbul ignore next */ if (true) {\n        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [\n            __webpack_require__(/*! stackframe */ \"(ssr)/./node_modules/stackframe/stackframe.js\")\n        ], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n})(void 0, function ErrorStackParser(StackFrame) {\n    \"use strict\";\n    var FIREFOX_SAFARI_STACK_REGEXP = /(^|@)\\S+:\\d+/;\n    var CHROME_IE_STACK_REGEXP = /^\\s*at .*(\\S+:\\d+|\\(native\\))/m;\n    var SAFARI_NATIVE_CODE_REGEXP = /^(eval@)?(\\[native code])?$/;\n    return {\n        /**\n         * Given an Error object, extract the most information from it.\n         *\n         * @param {Error} error object\n         * @return {Array} of StackFrames\n         */ parse: function ErrorStackParser$$parse(error) {\n            if (typeof error.stacktrace !== \"undefined\" || typeof error[\"opera#sourceloc\"] !== \"undefined\") {\n                return this.parseOpera(error);\n            } else if (error.stack && error.stack.match(CHROME_IE_STACK_REGEXP)) {\n                return this.parseV8OrIE(error);\n            } else if (error.stack) {\n                return this.parseFFOrSafari(error);\n            } else {\n                throw new Error(\"Cannot parse given Error object\");\n            }\n        },\n        // Separate line and column numbers from a string of the form: (URI:Line:Column)\n        extractLocation: function ErrorStackParser$$extractLocation(urlLike) {\n            // Fail-fast but return locations like \"(native)\"\n            if (urlLike.indexOf(\":\") === -1) {\n                return [\n                    urlLike\n                ];\n            }\n            var regExp = /(.+?)(?::(\\d+))?(?::(\\d+))?$/;\n            var parts = regExp.exec(urlLike.replace(/[()]/g, \"\"));\n            return [\n                parts[1],\n                parts[2] || undefined,\n                parts[3] || undefined\n            ];\n        },\n        parseV8OrIE: function ErrorStackParser$$parseV8OrIE(error) {\n            var filtered = error.stack.split(\"\\n\").filter(function(line) {\n                return !!line.match(CHROME_IE_STACK_REGEXP);\n            }, this);\n            return filtered.map(function(line) {\n                if (line.indexOf(\"(eval \") > -1) {\n                    // Throw away eval information until we implement stacktrace.js/stackframe#8\n                    line = line.replace(/eval code/g, \"eval\").replace(/(\\(eval at [^()]*)|(,.*$)/g, \"\");\n                }\n                var sanitizedLine = line.replace(/^\\s+/, \"\").replace(/\\(eval code/g, \"(\").replace(/^.*?\\s+/, \"\");\n                // capture and preseve the parenthesized location \"(/foo/my bar.js:12:87)\" in\n                // case it has spaces in it, as the string is split on \\s+ later on\n                var location = sanitizedLine.match(/ (\\(.+\\)$)/);\n                // remove the parenthesized location from the line, if it was matched\n                sanitizedLine = location ? sanitizedLine.replace(location[0], \"\") : sanitizedLine;\n                // if a location was matched, pass it to extractLocation() otherwise pass all sanitizedLine\n                // because this line doesn't have function name\n                var locationParts = this.extractLocation(location ? location[1] : sanitizedLine);\n                var functionName = location && sanitizedLine || undefined;\n                var fileName = [\n                    \"eval\",\n                    \"<anonymous>\"\n                ].indexOf(locationParts[0]) > -1 ? undefined : locationParts[0];\n                return new StackFrame({\n                    functionName: functionName,\n                    fileName: fileName,\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        },\n        parseFFOrSafari: function ErrorStackParser$$parseFFOrSafari(error) {\n            var filtered = error.stack.split(\"\\n\").filter(function(line) {\n                return !line.match(SAFARI_NATIVE_CODE_REGEXP);\n            }, this);\n            return filtered.map(function(line) {\n                // Throw away eval information until we implement stacktrace.js/stackframe#8\n                if (line.indexOf(\" > eval\") > -1) {\n                    line = line.replace(/ line (\\d+)(?: > eval line \\d+)* > eval:\\d+:\\d+/g, \":$1\");\n                }\n                if (line.indexOf(\"@\") === -1 && line.indexOf(\":\") === -1) {\n                    // Safari eval frames only have function names and nothing else\n                    return new StackFrame({\n                        functionName: line\n                    });\n                } else {\n                    var functionNameRegex = /((.*\".+\"[^@]*)?[^@]*)(?:@)/;\n                    var matches = line.match(functionNameRegex);\n                    var functionName = matches && matches[1] ? matches[1] : undefined;\n                    var locationParts = this.extractLocation(line.replace(functionNameRegex, \"\"));\n                    return new StackFrame({\n                        functionName: functionName,\n                        fileName: locationParts[0],\n                        lineNumber: locationParts[1],\n                        columnNumber: locationParts[2],\n                        source: line\n                    });\n                }\n            }, this);\n        },\n        parseOpera: function ErrorStackParser$$parseOpera(e) {\n            if (!e.stacktrace || e.message.indexOf(\"\\n\") > -1 && e.message.split(\"\\n\").length > e.stacktrace.split(\"\\n\").length) {\n                return this.parseOpera9(e);\n            } else if (!e.stack) {\n                return this.parseOpera10(e);\n            } else {\n                return this.parseOpera11(e);\n            }\n        },\n        parseOpera9: function ErrorStackParser$$parseOpera9(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)/i;\n            var lines = e.message.split(\"\\n\");\n            var result = [];\n            for(var i = 2, len = lines.length; i < len; i += 2){\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame({\n                        fileName: match[2],\n                        lineNumber: match[1],\n                        source: lines[i]\n                    }));\n                }\n            }\n            return result;\n        },\n        parseOpera10: function ErrorStackParser$$parseOpera10(e) {\n            var lineRE = /Line (\\d+).*script (?:in )?(\\S+)(?:: In function (\\S+))?$/i;\n            var lines = e.stacktrace.split(\"\\n\");\n            var result = [];\n            for(var i = 0, len = lines.length; i < len; i += 2){\n                var match = lineRE.exec(lines[i]);\n                if (match) {\n                    result.push(new StackFrame({\n                        functionName: match[3] || undefined,\n                        fileName: match[2],\n                        lineNumber: match[1],\n                        source: lines[i]\n                    }));\n                }\n            }\n            return result;\n        },\n        // Opera 10.65+ Error.stack very similar to FF/Safari\n        parseOpera11: function ErrorStackParser$$parseOpera11(error) {\n            var filtered = error.stack.split(\"\\n\").filter(function(line) {\n                return !!line.match(FIREFOX_SAFARI_STACK_REGEXP) && !line.match(/^Error created at/);\n            }, this);\n            return filtered.map(function(line) {\n                var tokens = line.split(\"@\");\n                var locationParts = this.extractLocation(tokens.pop());\n                var functionCall = tokens.shift() || \"\";\n                var functionName = functionCall.replace(/<anonymous function(: (\\w+))?>/, \"$2\").replace(/\\([^)]*\\)/g, \"\") || undefined;\n                var argsRaw;\n                if (functionCall.match(/\\(([^)]*)\\)/)) {\n                    argsRaw = functionCall.replace(/^[^(]+\\(([^)]*)\\)$/, \"$1\");\n                }\n                var args = argsRaw === undefined || argsRaw === \"[arguments not available]\" ? undefined : argsRaw.split(\",\");\n                return new StackFrame({\n                    functionName: functionName,\n                    args: args,\n                    fileName: locationParts[0],\n                    lineNumber: locationParts[1],\n                    columnNumber: locationParts[2],\n                    source: line\n                });\n            }, this);\n        }\n    };\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvZXJyb3Itc3RhY2stcGFyc2VyL2Vycm9yLXN0YWNrLXBhcnNlci5qcyIsIm1hcHBpbmdzIjoiO0FBQUMsVUFBU0EsSUFBSSxFQUFFQyxPQUFPO0lBQ25CO0lBQ0EsMkZBQTJGO0lBRTNGLHdCQUF3QixHQUN4QixJQUFJLElBQTBDLEVBQUU7UUFDNUNDLGlDQUE2QjtZQUFDO1NBQWEsb0NBQUVELE9BQU9BO0FBQUE7QUFBQTtBQUFBLGtHQUFDQTtJQUN6RCxPQUFPLEVBSU47QUFDTCxHQUFFLFFBQU0sU0FBU00saUJBQWlCQyxVQUFVO0lBQ3hDO0lBRUEsSUFBSUMsOEJBQThCO0lBQ2xDLElBQUlDLHlCQUF5QjtJQUM3QixJQUFJQyw0QkFBNEI7SUFFaEMsT0FBTztRQUNIOzs7OztTQUtDLEdBQ0RDLE9BQU8sU0FBU0Msd0JBQXdCQyxLQUFLO1lBQ3pDLElBQUksT0FBT0EsTUFBTUMsVUFBVSxLQUFLLGVBQWUsT0FBT0QsS0FBSyxDQUFDLGtCQUFrQixLQUFLLGFBQWE7Z0JBQzVGLE9BQU8sSUFBSSxDQUFDRSxVQUFVLENBQUNGO1lBQzNCLE9BQU8sSUFBSUEsTUFBTUcsS0FBSyxJQUFJSCxNQUFNRyxLQUFLLENBQUNDLEtBQUssQ0FBQ1IseUJBQXlCO2dCQUNqRSxPQUFPLElBQUksQ0FBQ1MsV0FBVyxDQUFDTDtZQUM1QixPQUFPLElBQUlBLE1BQU1HLEtBQUssRUFBRTtnQkFDcEIsT0FBTyxJQUFJLENBQUNHLGVBQWUsQ0FBQ047WUFDaEMsT0FBTztnQkFDSCxNQUFNLElBQUlPLE1BQU07WUFDcEI7UUFDSjtRQUVBLGdGQUFnRjtRQUNoRkMsaUJBQWlCLFNBQVNDLGtDQUFrQ0MsT0FBTztZQUMvRCxpREFBaUQ7WUFDakQsSUFBSUEsUUFBUUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxHQUFHO2dCQUM3QixPQUFPO29CQUFDRDtpQkFBUTtZQUNwQjtZQUVBLElBQUlFLFNBQVM7WUFDYixJQUFJQyxRQUFRRCxPQUFPRSxJQUFJLENB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QUFJRixhQUFhaEQsS0FBSyxDQUFDLGdCQUFnQjtvQkFDbkNrRCxVQUFVRixhQUFhckMsT0FBTyxDQUFDLHNCQUFzQjtnQkFDekQ7Z0JBQ0EsSUFBSXdDLE9BQU8sWUFBYXZDLGFBQWFzQyxZQUFZLDhCQUM3Q3RDLFlBQVlzQyxRQUFRbkMsS0FBSyxDQUFDO2dCQUU5QixPQUFPLElBQUl6QixXQUFXO29CQUNsQmdDLGNBQWNBO29CQUNkNkIsTUFBTUE7b0JBQ041QixVQUFVRixhQUFhLENBQUMsRUFBRTtvQkFDMUJHLFlBQVlILGFBQWEsQ0FBQyxFQUFFO29CQUM1QkksY0FBY0osYUFBYSxDQUFDLEVBQUU7b0JBQzlCSyxRQUFRVDtnQkFDWjtZQUNKLEdBQUcsSUFBSTtRQUNYO0lBQ0o7QUFDSiIsInNvdXJjZXMiOlsid2VicGFjazovL2Rhc2hib2FyZC8uL25vZGVfbW9kdWxlcy9lcnJvci1zdGFjay1wYXJzZXIvZXJyb3Itc3RhY2stcGFyc2VyLmpzPzA3ODAiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKHJvb3QsIGZhY3RvcnkpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgLy8gVW5pdmVyc2FsIE1vZHVsZSBEZWZpbml0aW9uIChVTUQpIHRvIHN1cHBvcnQgQU1ELCBDb21tb25KUy9Ob2RlLmpzLCBSaGlubywgYW5kIGJyb3dzZXJzLlxuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZSgnZXJyb3Itc3RhY2stcGFyc2VyJywgWydzdGFja2ZyYW1lJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeShyZXF1aXJlKCdzdGFja2ZyYW1lJykpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJvb3QuRXJyb3JTdGFja1BhcnNlciA9IGZhY3Rvcnkocm9vdC5TdGFja0ZyYW1lKTtcbiAgICB9XG59KHRoaXMsIGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIoU3RhY2tGcmFtZSkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAgPSAvKF58QClcXFMrOlxcZCsvO1xuICAgIHZhciBDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQID0gL15cXHMqYXQgLiooXFxTKzpcXGQrfFxcKG5hdGl2ZVxcKSkvbTtcbiAgICB2YXIgU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCA9IC9eKGV2YWxAKT8oXFxbbmF0aXZlIGNvZGVdKT8kLztcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHaXZlbiBhbiBFcnJvciBvYmplY3QsIGV4dHJhY3QgdGhlIG1vc3QgaW5mb3JtYXRpb24gZnJvbSBpdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICAgICAqIEByZXR1cm4ge0FycmF5fSBvZiBTdGFja0ZyYW1lc1xuICAgICAgICAgKi9cbiAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGVycm9yLnN0YWNrdHJhY2UgIT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlcnJvclsnb3BlcmEjc291cmNlbG9jJ10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VPcGVyYShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGVycm9yLnN0YWNrICYmIGVycm9yLnN0YWNrLm1hdGNoKENIUk9NRV9JRV9TVEFDS19SRUdFWFApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VWOE9ySUUoZXJyb3IpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChlcnJvci5zdGFjaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRkZPclNhZmFyaShlcnJvcik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHBhcnNlIGdpdmVuIEVycm9yIG9iamVjdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIFNlcGFyYXRlIGxpbmUgYW5kIGNvbHVtbiBudW1iZXJzIGZyb20gYSBzdHJpbmcgb2YgdGhlIGZvcm06IChVUkk6TGluZTpDb2x1bW4pXG4gICAgICAgIGV4dHJhY3RMb2NhdGlvbjogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkZXh0cmFjdExvY2F0aW9uKHVybExpa2UpIHtcbiAgICAgICAgICAgIC8vIEZhaWwtZmFzdCBidXQgcmV0dXJuIGxvY2F0aW9ucyBsaWtlIFwiKG5hdGl2ZSlcIlxuICAgICAgICAgICAgaWYgKHVybExpa2UuaW5kZXhPZignOicpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbdXJsTGlrZV07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciByZWdFeHAgPSAvKC4rPykoPzo6KFxcZCspKT8oPzo6KFxcZCspKT8kLztcbiAgICAgICAgICAgIHZhciBwYXJ0cyA9IHJlZ0V4cC5leGVjKHVybExpa2UucmVwbGFjZSgvWygpXS9nLCAnJykpO1xuICAgICAgICAgICAgcmV0dXJuIFtwYXJ0c1sxXSwgcGFydHNbMl0gfHwgdW5kZWZpbmVkLCBwYXJ0c1szXSB8fCB1bmRlZmluZWRdO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlVjhPcklFOiBmdW5jdGlvbiBFcnJvclN0YWNrUGFyc2VyJCRwYXJzZVY4T3JJRShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQKTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyZWQubWFwKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICBpZiAobGluZS5pbmRleE9mKCcoZXZhbCAnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRocm93IGF3YXkgZXZhbCBpbmZvcm1hdGlvbiB1bnRpbCB3ZSBpbXBsZW1lbnQgc3RhY2t0cmFjZS5qcy9zdGFja2ZyYW1lIzhcbiAgICAgICAgICAgICAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgvZXZhbCBjb2RlL2csICdldmFsJykucmVwbGFjZSgvKFxcKGV2YWwgYXQgW14oKV0qKXwoLC4qJCkvZywgJycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgc2FuaXRpemVkTGluZSA9IGxpbmUucmVwbGFjZSgvXlxccysvLCAnJykucmVwbGFjZSgvXFwoZXZhbCBjb2RlL2csICcoJykucmVwbGFjZSgvXi4qP1xccysvLCAnJyk7XG5cbiAgICAgICAgICAgICAgICAvLyBjYXB0dXJlIGFuZCBwcmVzZXZlIHRoZSBwYXJlbnRoZXNpemVkIGxvY2F0aW9uIFwiKC9mb28vbXkgYmFyLmpzOjEyOjg3KVwiIGluXG4gICAgICAgICAgICAgICAgLy8gY2FzZSBpdCBoYXMgc3BhY2VzIGluIGl0LCBhcyB0aGUgc3RyaW5nIGlzIHNwbGl0IG9uIFxccysgbGF0ZXIgb25cbiAgICAgICAgICAgICAgICB2YXIgbG9jYXRpb24gPSBzYW5pdGl6ZWRMaW5lLm1hdGNoKC8gKFxcKC4rXFwpJCkvKTtcblxuICAgICAgICAgICAgICAgIC8vIHJlbW92ZSB0aGUgcGFyZW50aGVzaXplZCBsb2NhdGlvbiBmcm9tIHRoZSBsaW5lLCBpZiBpdCB3YXMgbWF0Y2hlZFxuICAgICAgICAgICAgICAgIHNhbml0aXplZExpbmUgPSBsb2NhdGlvbiA/IHNhbml0aXplZExpbmUucmVwbGFjZShsb2NhdGlvblswXSwgJycpIDogc2FuaXRpemVkTGluZTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGEgbG9jYXRpb24gd2FzIG1hdGNoZWQsIHBhc3MgaXQgdG8gZXh0cmFjdExvY2F0aW9uKCkgb3RoZXJ3aXNlIHBhc3MgYWxsIHNhbml0aXplZExpbmVcbiAgICAgICAgICAgICAgICAvLyBiZWNhdXNlIHRoaXMgbGluZSBkb2Vzbid0IGhhdmUgZnVuY3Rpb24gbmFtZVxuICAgICAgICAgICAgICAgIHZhciBsb2NhdGlvblBhcnRzID0gdGhpcy5leHRyYWN0TG9jYXRpb24obG9jYXRpb24gPyBsb2NhdGlvblsxXSA6IHNhbml0aXplZExpbmUpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBsb2NhdGlvbiAmJiBzYW5pdGl6ZWRMaW5lIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgZmlsZU5hbWUgPSBbJ2V2YWwnLCAnPGFub255bW91cz4nXS5pbmRleE9mKGxvY2F0aW9uUGFydHNbMF0pID4gLTEgPyB1bmRlZmluZWQgOiBsb2NhdGlvblBhcnRzWzBdO1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb25OYW1lOiBmdW5jdGlvbk5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBmaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlRkZPclNhZmFyaTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VGRk9yU2FmYXJpKGVycm9yKSB7XG4gICAgICAgICAgICB2YXIgZmlsdGVyZWQgPSBlcnJvci5zdGFjay5zcGxpdCgnXFxuJykuZmlsdGVyKGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gIWxpbmUubWF0Y2goU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCk7XG4gICAgICAgICAgICB9LCB0aGlzKTtcblxuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcmVkLm1hcChmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgLy8gVGhyb3cgYXdheSBldmFsIGluZm9ybWF0aW9uIHVudGlsIHdlIGltcGxlbWVudCBzdGFja3RyYWNlLmpzL3N0YWNrZnJhbWUjOFxuICAgICAgICAgICAgICAgIGlmIChsaW5lLmluZGV4T2YoJyA+IGV2YWwnKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpbmUgPSBsaW5lLnJlcGxhY2UoLyBsaW5lIChcXGQrKSg/OiA+IGV2YWwgbGluZSBcXGQrKSogPiBldmFsOlxcZCs6XFxkKy9nLCAnOiQxJyk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKGxpbmUuaW5kZXhPZignQCcpID09PSAtMSAmJiBsaW5lLmluZGV4T2YoJzonKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2FmYXJpIGV2YWwgZnJhbWVzIG9ubHkgaGF2ZSBmdW5jdGlvbiBuYW1lcyBhbmQgbm90aGluZyBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbk5hbWU6IGxpbmVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGZ1bmN0aW9uTmFtZVJlZ2V4ID0gLygoLipcIi4rXCJbXkBdKik/W15AXSopKD86QCkvO1xuICAgICAgICAgICAgICAgICAgICB2YXIgbWF0Y2hlcyA9IGxpbmUubWF0Y2goZnVuY3Rpb25OYW1lUmVnZXgpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgZnVuY3Rpb25OYW1lID0gbWF0Y2hlcyAmJiBtYXRjaGVzWzFdID8gbWF0Y2hlc1sxXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbihsaW5lLnJlcGxhY2UoZnVuY3Rpb25OYW1lUmVnZXgsICcnKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZU5hbWU6IGxvY2F0aW9uUGFydHNbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBsb2NhdGlvblBhcnRzWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmEoZSkge1xuICAgICAgICAgICAgaWYgKCFlLnN0YWNrdHJhY2UgfHwgKGUubWVzc2FnZS5pbmRleE9mKCdcXG4nKSA+IC0xICYmXG4gICAgICAgICAgICAgICAgZS5tZXNzYWdlLnNwbGl0KCdcXG4nKS5sZW5ndGggPiBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhOShlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIWUuc3RhY2spIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZU9wZXJhMTAoZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlT3BlcmExMShlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICBwYXJzZU9wZXJhOTogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTkoZSkge1xuICAgICAgICAgICAgdmFyIGxpbmVSRSA9IC9MaW5lIChcXGQrKS4qc2NyaXB0ICg/OmluICk/KFxcUyspL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLm1lc3NhZ2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMiwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5ldyBTdGFja0ZyYW1lKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxpbmVOdW1iZXI6IG1hdGNoWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgc291cmNlOiBsaW5lc1tpXVxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9LFxuXG4gICAgICAgIHBhcnNlT3BlcmExMDogZnVuY3Rpb24gRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTEwKGUpIHtcbiAgICAgICAgICAgIHZhciBsaW5lUkUgPSAvTGluZSAoXFxkKykuKnNjcmlwdCAoPzppbiApPyhcXFMrKSg/OjogSW4gZnVuY3Rpb24gKFxcUyspKT8kL2k7XG4gICAgICAgICAgICB2YXIgbGluZXMgPSBlLnN0YWNrdHJhY2Uuc3BsaXQoJ1xcbicpO1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbGluZXMubGVuZ3RoOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSBsaW5lUkUuZXhlYyhsaW5lc1tpXSk7XG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3IFN0YWNrRnJhbWUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogbWF0Y2hbM10gfHwgdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbGVOYW1lOiBtYXRjaFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lTnVtYmVyOiBtYXRjaFsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVzW2ldXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBPcGVyYSAxMC42NSsgRXJyb3Iuc3RhY2sgdmVyeSBzaW1pbGFyIHRvIEZGL1NhZmFyaVxuICAgICAgICBwYXJzZU9wZXJhMTE6IGZ1bmN0aW9uIEVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmExMShlcnJvcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlcmVkID0gZXJyb3Iuc3RhY2suc3BsaXQoJ1xcbicpLmZpbHRlcihmdW5jdGlvbihsaW5lKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhbGluZS5tYXRjaChGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFApICYmICFsaW5lLm1hdGNoKC9eRXJyb3IgY3JlYXRlZCBhdC8pO1xuICAgICAgICAgICAgfSwgdGhpcyk7XG5cbiAgICAgICAgICAgIHJldHVybiBmaWx0ZXJlZC5tYXAoZnVuY3Rpb24obGluZSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBsaW5lLnNwbGl0KCdAJyk7XG4gICAgICAgICAgICAgICAgdmFyIGxvY2F0aW9uUGFydHMgPSB0aGlzLmV4dHJhY3RMb2NhdGlvbih0b2tlbnMucG9wKCkpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbkNhbGwgPSAodG9rZW5zLnNoaWZ0KCkgfHwgJycpO1xuICAgICAgICAgICAgICAgIHZhciBmdW5jdGlvbk5hbWUgPSBmdW5jdGlvbkNhbGxcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLzxhbm9ueW1vdXMgZnVuY3Rpb24oOiAoXFx3KykpPz4vLCAnJDInKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFwoW14pXSpcXCkvZywgJycpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgYXJnc1JhdztcbiAgICAgICAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsLm1hdGNoKC9cXCgoW14pXSopXFwpLykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXJnc1JhdyA9IGZ1bmN0aW9uQ2FsbC5yZXBsYWNlKC9eW14oXStcXCgoW14pXSopXFwpJC8sICckMScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IChhcmdzUmF3ID09PSB1bmRlZmluZWQgfHwgYXJnc1JhdyA9PT0gJ1thcmd1bWVudHMgbm90IGF2YWlsYWJsZV0nKSA/XG4gICAgICAgICAgICAgICAgICAgIHVuZGVmaW5lZCA6IGFyZ3NSYXcuc3BsaXQoJywnKTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgU3RhY2tGcmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uTmFtZTogZnVuY3Rpb25OYW1lLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBhcmdzLFxuICAgICAgICAgICAgICAgICAgICBmaWxlTmFtZTogbG9jYXRpb25QYXJ0c1swXSxcbiAgICAgICAgICAgICAgICAgICAgbGluZU51bWJlcjogbG9jYXRpb25QYXJ0c1sxXSxcbiAgICAgICAgICAgICAgICAgICAgY29sdW1uTnVtYmVyOiBsb2NhdGlvblBhcnRzWzJdLFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2U6IGxpbmVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMpO1xuICAgICAgICB9XG4gICAgfTtcbn0pKTtcbiJdLCJuYW1lcyI6WyJyb290IiwiZmFjdG9yeSIsImRlZmluZSIsImFtZCIsImV4cG9ydHMiLCJtb2R1bGUiLCJyZXF1aXJlIiwiRXJyb3JTdGFja1BhcnNlciIsIlN0YWNrRnJhbWUiLCJGSVJFRk9YX1NBRkFSSV9TVEFDS19SRUdFWFAiLCJDSFJPTUVfSUVfU1RBQ0tfUkVHRVhQIiwiU0FGQVJJX05BVElWRV9DT0RFX1JFR0VYUCIsInBhcnNlIiwiRXJyb3JTdGFja1BhcnNlciQkcGFyc2UiLCJlcnJvciIsInN0YWNrdHJhY2UiLCJwYXJzZU9wZXJhIiwic3RhY2siLCJtYXRjaCIsInBhcnNlVjhPcklFIiwicGFyc2VGRk9yU2FmYXJpIiwiRXJyb3IiLCJleHRyYWN0TG9jYXRpb24iLCJFcnJvclN0YWNrUGFyc2VyJCRleHRyYWN0TG9jYXRpb24iLCJ1cmxMaWtlIiwiaW5kZXhPZiIsInJlZ0V4cCIsInBhcnRzIiwiZXhlYyIsInJlcGxhY2UiLCJ1bmRlZmluZWQiLCJFcnJvclN0YWNrUGFyc2VyJCRwYXJzZVY4T3JJRSIsImZpbHRlcmVkIiwic3BsaXQiLCJmaWx0ZXIiLCJsaW5lIiwibWFwIiwic2FuaXRpemVkTGluZSIsImxvY2F0aW9uIiwibG9jYXRpb25QYXJ0cyIsImZ1bmN0aW9uTmFtZSIsImZpbGVOYW1lIiwibGluZU51bWJlciIsImNvbHVtbk51bWJlciIsInNvdXJjZSIsIkVycm9yU3RhY2tQYXJzZXIkJHBhcnNlRkZPclNhZmFyaSIsImZ1bmN0aW9uTmFtZVJlZ2V4IiwibWF0Y2hlcyIsIkVycm9yU3RhY2tQYXJzZXIkJHBhcnNlT3BlcmEiLCJlIiwibWVzc2FnZSIsImxlbmd0aCIsInBhcnNlT3BlcmE5IiwicGFyc2VPcGVyYTEwIiwicGFyc2VPcGVyYTExIiwiRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTkiLCJsaW5lUkUiLCJsaW5lcyIsInJlc3VsdCIsImkiLCJsZW4iLCJwdXNoIiwiRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTEwIiwiRXJyb3JTdGFja1BhcnNlciQkcGFyc2VPcGVyYTExIiwidG9rZW5zIiwicG9wIiwiZnVuY3Rpb25DYWxsIiwic2hpZnQiLCJhcmdzUmF3IiwiYXJncyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/error-stack-parser/error-stack-parser.js\n");

/***/ })

};
;