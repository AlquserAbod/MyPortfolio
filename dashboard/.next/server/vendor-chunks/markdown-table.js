"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/markdown-table";
exports.ids = ["vendor-chunks/markdown-table"];
exports.modules = {

/***/ "(ssr)/./node_modules/markdown-table/index.js":
/*!**********************************************!*\
  !*** ./node_modules/markdown-table/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar repeat = __webpack_require__(/*! repeat-string */ \"(ssr)/./node_modules/repeat-string/index.js\");\nmodule.exports = markdownTable;\nvar trailingWhitespace = / +$/;\n// Characters.\nvar space = \" \";\nvar lineFeed = \"\\n\";\nvar dash = \"-\";\nvar colon = \":\";\nvar verticalBar = \"|\";\nvar x = 0;\nvar C = 67;\nvar L = 76;\nvar R = 82;\nvar c = 99;\nvar l = 108;\nvar r = 114;\n// Create a table from a matrix of strings.\nfunction markdownTable(table, options) {\n    var settings = options || {};\n    var padding = settings.padding !== false;\n    var start = settings.delimiterStart !== false;\n    var end = settings.delimiterEnd !== false;\n    var align = (settings.align || []).concat();\n    var alignDelimiters = settings.alignDelimiters !== false;\n    var alignments = [];\n    var stringLength = settings.stringLength || defaultStringLength;\n    var rowIndex = -1;\n    var rowLength = table.length;\n    var cellMatrix = [];\n    var sizeMatrix = [];\n    var row = [];\n    var sizes = [];\n    var longestCellByColumn = [];\n    var mostCellsPerRow = 0;\n    var cells;\n    var columnIndex;\n    var columnLength;\n    var largest;\n    var size;\n    var cell;\n    var lines;\n    var line;\n    var before;\n    var after;\n    var code;\n    // This is a superfluous loop if we don’t align delimiters, but otherwise we’d\n    // do superfluous work when aligning, so optimize for aligning.\n    while(++rowIndex < rowLength){\n        cells = table[rowIndex];\n        columnIndex = -1;\n        columnLength = cells.length;\n        row = [];\n        sizes = [];\n        if (columnLength > mostCellsPerRow) {\n            mostCellsPerRow = columnLength;\n        }\n        while(++columnIndex < columnLength){\n            cell = serialize(cells[columnIndex]);\n            if (alignDelimiters === true) {\n                size = stringLength(cell);\n                sizes[columnIndex] = size;\n                largest = longestCellByColumn[columnIndex];\n                if (largest === undefined || size > largest) {\n                    longestCellByColumn[columnIndex] = size;\n                }\n            }\n            row.push(cell);\n        }\n        cellMatrix[rowIndex] = row;\n        sizeMatrix[rowIndex] = sizes;\n    }\n    // Figure out which alignments to use.\n    columnIndex = -1;\n    columnLength = mostCellsPerRow;\n    if (typeof align === \"object\" && \"length\" in align) {\n        while(++columnIndex < columnLength){\n            alignments[columnIndex] = toAlignment(align[columnIndex]);\n        }\n    } else {\n        code = toAlignment(align);\n        while(++columnIndex < columnLength){\n            alignments[columnIndex] = code;\n        }\n    }\n    // Inject the alignment row.\n    columnIndex = -1;\n    columnLength = mostCellsPerRow;\n    row = [];\n    sizes = [];\n    while(++columnIndex < columnLength){\n        code = alignments[columnIndex];\n        before = \"\";\n        after = \"\";\n        if (code === l) {\n            before = colon;\n        } else if (code === r) {\n            after = colon;\n        } else if (code === c) {\n            before = colon;\n            after = colon;\n        }\n        // There *must* be at least one hyphen-minus in each alignment cell.\n        size = alignDelimiters ? Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length) : 1;\n        cell = before + repeat(dash, size) + after;\n        if (alignDelimiters === true) {\n            size = before.length + size + after.length;\n            if (size > longestCellByColumn[columnIndex]) {\n                longestCellByColumn[columnIndex] = size;\n            }\n            sizes[columnIndex] = size;\n        }\n        row[columnIndex] = cell;\n    }\n    // Inject the alignment row.\n    cellMatrix.splice(1, 0, row);\n    sizeMatrix.splice(1, 0, sizes);\n    rowIndex = -1;\n    rowLength = cellMatrix.length;\n    lines = [];\n    while(++rowIndex < rowLength){\n        row = cellMatrix[rowIndex];\n        sizes = sizeMatrix[rowIndex];\n        columnIndex = -1;\n        columnLength = mostCellsPerRow;\n        line = [];\n        while(++columnIndex < columnLength){\n            cell = row[columnIndex] || \"\";\n            before = \"\";\n            after = \"\";\n            if (alignDelimiters === true) {\n                size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);\n                code = alignments[columnIndex];\n                if (code === r) {\n                    before = repeat(space, size);\n                } else if (code === c) {\n                    if (size % 2 === 0) {\n                        before = repeat(space, size / 2);\n                        after = before;\n                    } else {\n                        before = repeat(space, size / 2 + 0.5);\n                        after = repeat(space, size / 2 - 0.5);\n                    }\n                } else {\n                    after = repeat(space, size);\n                }\n            }\n            if (start === true && columnIndex === 0) {\n                line.push(verticalBar);\n            }\n            if (padding === true && // Don’t add the opening space if we’re not aligning and the cell is\n            // empty: there will be a closing space.\n            !(alignDelimiters === false && cell === \"\") && (start === true || columnIndex !== 0)) {\n                line.push(space);\n            }\n            if (alignDelimiters === true) {\n                line.push(before);\n            }\n            line.push(cell);\n            if (alignDelimiters === true) {\n                line.push(after);\n            }\n            if (padding === true) {\n                line.push(space);\n            }\n            if (end === true || columnIndex !== columnLength - 1) {\n                line.push(verticalBar);\n            }\n        }\n        line = line.join(\"\");\n        if (end === false) {\n            line = line.replace(trailingWhitespace, \"\");\n        }\n        lines.push(line);\n    }\n    return lines.join(lineFeed);\n}\nfunction serialize(value) {\n    return value === null || value === undefined ? \"\" : String(value);\n}\nfunction defaultStringLength(value) {\n    return value.length;\n}\nfunction toAlignment(value) {\n    var code = typeof value === \"string\" ? value.charCodeAt(0) : x;\n    return code === L || code === l ? l : code === R || code === r ? r : code === C || code === c ? c : x;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbWFya2Rvd24tdGFibGUvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxTQUFTQyxtQkFBT0EsQ0FBQztBQUVyQkMsT0FBT0MsT0FBTyxHQUFHQztBQUVqQixJQUFJQyxxQkFBcUI7QUFFekIsY0FBYztBQUNkLElBQUlDLFFBQVE7QUFDWixJQUFJQyxXQUFXO0FBQ2YsSUFBSUMsT0FBTztBQUNYLElBQUlDLFFBQVE7QUFDWixJQUFJQyxjQUFjO0FBRWxCLElBQUlDLElBQUk7QUFDUixJQUFJQyxJQUFJO0FBQ1IsSUFBSUMsSUFBSTtBQUNSLElBQUlDLElBQUk7QUFDUixJQUFJQyxJQUFJO0FBQ1IsSUFBSUMsSUFBSTtBQUNSLElBQUlDLElBQUk7QUFFUiwyQ0FBMkM7QUFDM0MsU0FBU2IsY0FBY2MsS0FBSyxFQUFFQyxPQUFPO0lBQ25DLElBQUlDLFdBQVdELFdBQVcsQ0FBQztJQUMzQixJQUFJRSxVQUFVRCxTQUFTQyxPQUFPLEtBQUs7SUFDbkMsSUFBSUMsUUFBUUYsU0FBU0csY0FBYyxLQUFLO0lBQ3hDLElBQUlDLE1BQU1KLFNBQVNLLFlBQVksS0FBSztJQUNwQyxJQUFJQyxRQUFRLENBQUNOLFNBQVNNLEtBQUssSUFBSSxFQUFFLEVBQUVDLE1BQU07SUFDekMsSUFBSUMsa0JBQWtCUixTQUFTUSxlQUFlLEtBQUs7SUFDbkQsSUFBSUMsYUFBYSxFQUFFO0lBQ25CLElBQUlDLGVBQWVWLFNBQVNVLFlBQVksSUFBSUM7SUFDNUMsSUFBSUMsV0FBVyxDQUFDO0lBQ2hCLElBQUlDLFlBQVlmLE1BQU1nQixNQUFNO0lBQzVCLElBQUlDLGFBQWEsRUFBRTtJQUNuQixJQUFJQyxhQUFhLEVBQUU7SUFDbkIsSUFBSUMsTUFBTSxFQUFFO0lBQ1osSUFBSUMsUUFBUSxFQUFFO0lBQ2QsSUFBSUMsc0JBQXNCLEVBQUU7SUFDNUIsSUFBSUMsa0JBQWtCO0lBQ3RCLElBQUlDO0lBQ0osSUFBSUM7SUFDSixJQUFJQztJ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QUVBLElBQUk3QixZQUFZLE1BQU07Z0JBQ3BCMkIsS0FBS00sSUFBSSxDQUFDaEQ7WUFDWjtZQUVBLElBQUlrQixRQUFRLFFBQVFrQixnQkFBZ0JDLGVBQWUsR0FBRztnQkFDcERLLEtBQUtNLElBQUksQ0FBQzVDO1lBQ1o7UUFDRjtRQUVBc0MsT0FBT0EsS0FBS1csSUFBSSxDQUFDO1FBRWpCLElBQUluQyxRQUFRLE9BQU87WUFDakJ3QixPQUFPQSxLQUFLWSxPQUFPLENBQUN2RCxvQkFBb0I7UUFDMUM7UUFFQTBDLE1BQU1PLElBQUksQ0FBQ047SUFDYjtJQUVBLE9BQU9ELE1BQU1ZLElBQUksQ0FBQ3BEO0FBQ3BCO0FBRUEsU0FBUzZDLFVBQVVTLEtBQUs7SUFDdEIsT0FBT0EsVUFBVSxRQUFRQSxVQUFVUixZQUFZLEtBQUtTLE9BQU9EO0FBQzdEO0FBRUEsU0FBUzlCLG9CQUFvQjhCLEtBQUs7SUFDaEMsT0FBT0EsTUFBTTNCLE1BQU07QUFDckI7QUFFQSxTQUFTcUIsWUFBWU0sS0FBSztJQUN4QixJQUFJVixPQUFPLE9BQU9VLFVBQVUsV0FBV0EsTUFBTUUsVUFBVSxDQUFDLEtBQUtwRDtJQUU3RCxPQUFPd0MsU0FBU3RDLEtBQUtzQyxTQUFTbkMsSUFDMUJBLElBQ0FtQyxTQUFTckMsS0FBS3FDLFNBQVNsQyxJQUN2QkEsSUFDQWtDLFNBQVN2QyxLQUFLdUMsU0FBU3BDLElBQ3ZCQSxJQUNBSjtBQUNOIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZGFzaGJvYXJkLy4vbm9kZV9tb2R1bGVzL21hcmtkb3duLXRhYmxlL2luZGV4LmpzPzk1Y2QiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciByZXBlYXQgPSByZXF1aXJlKCdyZXBlYXQtc3RyaW5nJylcblxubW9kdWxlLmV4cG9ydHMgPSBtYXJrZG93blRhYmxlXG5cbnZhciB0cmFpbGluZ1doaXRlc3BhY2UgPSAvICskL1xuXG4vLyBDaGFyYWN0ZXJzLlxudmFyIHNwYWNlID0gJyAnXG52YXIgbGluZUZlZWQgPSAnXFxuJ1xudmFyIGRhc2ggPSAnLSdcbnZhciBjb2xvbiA9ICc6J1xudmFyIHZlcnRpY2FsQmFyID0gJ3wnXG5cbnZhciB4ID0gMFxudmFyIEMgPSA2N1xudmFyIEwgPSA3NlxudmFyIFIgPSA4MlxudmFyIGMgPSA5OVxudmFyIGwgPSAxMDhcbnZhciByID0gMTE0XG5cbi8vIENyZWF0ZSBhIHRhYmxlIGZyb20gYSBtYXRyaXggb2Ygc3RyaW5ncy5cbmZ1bmN0aW9uIG1hcmtkb3duVGFibGUodGFibGUsIG9wdGlvbnMpIHtcbiAgdmFyIHNldHRpbmdzID0gb3B0aW9ucyB8fCB7fVxuICB2YXIgcGFkZGluZyA9IHNldHRpbmdzLnBhZGRpbmcgIT09IGZhbHNlXG4gIHZhciBzdGFydCA9IHNldHRpbmdzLmRlbGltaXRlclN0YXJ0ICE9PSBmYWxzZVxuICB2YXIgZW5kID0gc2V0dGluZ3MuZGVsaW1pdGVyRW5kICE9PSBmYWxzZVxuICB2YXIgYWxpZ24gPSAoc2V0dGluZ3MuYWxpZ24gfHwgW10pLmNvbmNhdCgpXG4gIHZhciBhbGlnbkRlbGltaXRlcnMgPSBzZXR0aW5ncy5hbGlnbkRlbGltaXRlcnMgIT09IGZhbHNlXG4gIHZhciBhbGlnbm1lbnRzID0gW11cbiAgdmFyIHN0cmluZ0xlbmd0aCA9IHNldHRpbmdzLnN0cmluZ0xlbmd0aCB8fCBkZWZhdWx0U3RyaW5nTGVuZ3RoXG4gIHZhciByb3dJbmRleCA9IC0xXG4gIHZhciByb3dMZW5ndGggPSB0YWJsZS5sZW5ndGhcbiAgdmFyIGNlbGxNYXRyaXggPSBbXVxuICB2YXIgc2l6ZU1hdHJpeCA9IFtdXG4gIHZhciByb3cgPSBbXVxuICB2YXIgc2l6ZXMgPSBbXVxuICB2YXIgbG9uZ2VzdENlbGxCeUNvbHVtbiA9IFtdXG4gIHZhciBtb3N0Q2VsbHNQZXJSb3cgPSAwXG4gIHZhciBjZWxsc1xuICB2YXIgY29sdW1uSW5kZXhcbiAgdmFyIGNvbHVtbkxlbmd0aFxuICB2YXIgbGFyZ2VzdFxuICB2YXIgc2l6ZVxuICB2YXIgY2VsbFxuICB2YXIgbGluZXNcbiAgdmFyIGxpbmVcbiAgdmFyIGJlZm9yZVxuICB2YXIgYWZ0ZXJcbiAgdmFyIGNvZGVcblxuICAvLyBUaGlzIGlzIGEgc3VwZXJmbHVvdXMgbG9vcCBpZiB3ZSBkb27igJl0IGFsaWduIGRlbGltaXRlcnMsIGJ1dCBvdGhlcndpc2Ugd2XigJlkXG4gIC8vIGRvIHN1cGVyZmx1b3VzIHdvcmsgd2hlbiBhbGlnbmluZywgc28gb3B0aW1pemUgZm9yIGFsaWduaW5nLlxuICB3aGlsZSAoKytyb3dJbmRleCA8IHJvd0xlbmd0aCkge1xuICAgIGNlbGxzID0gdGFibGVbcm93SW5kZXhdXG4gICAgY29sdW1uSW5kZXggPSAtMVxuICAgIGNvbHVtbkxlbmd0aCA9IGNlbGxzLmxlbmd0aFxuICAgIHJvdyA9IFtdXG4gICAgc2l6ZXMgPSBbXVxuXG4gICAgaWYgKGNvbHVtbkxlbmd0aCA+IG1vc3RDZWxsc1BlclJvdykge1xuICAgICAgbW9zdENlbGxzUGVyUm93ID0gY29sdW1uTGVuZ3RoXG4gICAgfVxuXG4gICAgd2hpbGUgKCsrY29sdW1uSW5kZXggPCBjb2x1bW5MZW5ndGgpIHtcbiAgICAgIGNlbGwgPSBzZXJpYWxpemUoY2VsbHNbY29sdW1uSW5kZXhdKVxuXG4gICAgICBpZiAoYWxpZ25EZWxpbWl0ZXJzID09PSB0cnVlKSB7XG4gICAgICAgIHNpemUgPSBzdHJpbmdMZW5ndGgoY2VsbClcbiAgICAgICAgc2l6ZXNbY29sdW1uSW5kZXhdID0gc2l6ZVxuXG4gICAgICAgIGxhcmdlc3QgPSBsb25nZXN0Q2VsbEJ5Q29sdW1uW2NvbHVtbkluZGV4XVxuXG4gICAgICAgIGlmIChsYXJnZXN0ID09PSB1bmRlZmluZWQgfHwgc2l6ZSA+IGxhcmdlc3QpIHtcbiAgICAgICAgICBsb25nZXN0Q2VsbEJ5Q29sdW1uW2NvbHVtbkluZGV4XSA9IHNpemVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByb3cucHVzaChjZWxsKVxuICAgIH1cblxuICAgIGNlbGxNYXRyaXhbcm93SW5kZXhdID0gcm93XG4gICAgc2l6ZU1hdHJpeFtyb3dJbmRleF0gPSBzaXplc1xuICB9XG5cbiAgLy8gRmlndXJlIG91dCB3aGljaCBhbGlnbm1lbnRzIHRvIHVzZS5cbiAgY29sdW1uSW5kZXggPSAtMVxuICBjb2x1bW5MZW5ndGggPSBtb3N0Q2VsbHNQZXJSb3dcblxuICBpZiAodHlwZW9mIGFsaWduID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBhbGlnbikge1xuICAgIHdoaWxlICgrK2NvbHVtbkluZGV4IDwgY29sdW1uTGVuZ3RoKSB7XG4gICAgICBhbGlnbm1lbnRzW2NvbHVtbkluZGV4XSA9IHRvQWxpZ25tZW50KGFsaWduW2NvbHVtbkluZGV4XSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29kZSA9IHRvQWxpZ25tZW50KGFsaWduKVxuXG4gICAgd2hpbGUgKCsrY29sdW1uSW5kZXggPCBjb2x1bW5MZW5ndGgpIHtcbiAgICAgIGFsaWdubWVudHNbY29sdW1uSW5kZXhdID0gY29kZVxuICAgIH1cbiAgfVxuXG4gIC8vIEluamVjdCB0aGUgYWxpZ25tZW50IHJvdy5cbiAgY29sdW1uSW5kZXggPSAtMVxuICBjb2x1bW5MZW5ndGggPSBtb3N0Q2VsbHNQZXJSb3dcbiAgcm93ID0gW11cbiAgc2l6ZXMgPSBbXVxuXG4gIHdoaWxlICgrK2NvbHVtbkluZGV4IDwgY29sdW1uTGVuZ3RoKSB7XG4gICAgY29kZSA9IGFsaWdubWVudHNbY29sdW1uSW5kZXhdXG4gICAgYmVmb3JlID0gJydcbiAgICBhZnRlciA9ICcnXG5cbiAgICBpZiAoY29kZSA9PT0gbCkge1xuICAgICAgYmVmb3JlID0gY29sb25cbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IHIpIHtcbiAgICAgIGFmdGVyID0gY29sb25cbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IGMpIHtcbiAgICAgIGJlZm9yZSA9IGNvbG9uXG4gICAgICBhZnRlciA9IGNvbG9uXG4gICAgfVxuXG4gICAgLy8gVGhlcmUgKm11c3QqIGJlIGF0IGxlYXN0IG9uZSBoeXBoZW4tbWludXMgaW4gZWFjaCBhbGlnbm1lbnQgY2VsbC5cbiAgICBzaXplID0gYWxpZ25EZWxpbWl0ZXJzXG4gICAgICA/IE1hdGgubWF4KFxuICAgICAgICAgIDEsXG4gICAgICAgICAgbG9uZ2VzdENlbGxCeUNvbHVtbltjb2x1bW5JbmRleF0gLSBiZWZvcmUubGVuZ3RoIC0gYWZ0ZXIubGVuZ3RoXG4gICAgICAgIClcbiAgICAgIDogMVxuXG4gICAgY2VsbCA9IGJlZm9yZSArIHJlcGVhdChkYXNoLCBzaXplKSArIGFmdGVyXG5cbiAgICBpZiAoYWxpZ25EZWxpbWl0ZXJzID09PSB0cnVlKSB7XG4gICAgICBzaXplID0gYmVmb3JlLmxlbmd0aCArIHNpemUgKyBhZnRlci5sZW5ndGhcblxuICAgICAgaWYgKHNpemUgPiBsb25nZXN0Q2VsbEJ5Q29sdW1uW2NvbHVtbkluZGV4XSkge1xuICAgICAgICBsb25nZXN0Q2VsbEJ5Q29sdW1uW2NvbHVtbkluZGV4XSA9IHNpemVcbiAgICAgIH1cblxuICAgICAgc2l6ZXNbY29sdW1uSW5kZXhdID0gc2l6ZVxuICAgIH1cblxuICAgIHJvd1tjb2x1bW5JbmRleF0gPSBjZWxsXG4gIH1cblxuICAvLyBJbmplY3QgdGhlIGFsaWdubWVudCByb3cuXG4gIGNlbGxNYXRyaXguc3BsaWNlKDEsIDAsIHJvdylcbiAgc2l6ZU1hdHJpeC5zcGxpY2UoMSwgMCwgc2l6ZXMpXG5cbiAgcm93SW5kZXggPSAtMVxuICByb3dMZW5ndGggPSBjZWxsTWF0cml4Lmxlbmd0aFxuICBsaW5lcyA9IFtdXG5cbiAgd2hpbGUgKCsrcm93SW5kZXggPCByb3dMZW5ndGgpIHtcbiAgICByb3cgPSBjZWxsTWF0cml4W3Jvd0luZGV4XVxuICAgIHNpemVzID0gc2l6ZU1hdHJpeFtyb3dJbmRleF1cbiAgICBjb2x1bW5JbmRleCA9IC0xXG4gICAgY29sdW1uTGVuZ3RoID0gbW9zdENlbGxzUGVyUm93XG4gICAgbGluZSA9IFtdXG5cbiAgICB3aGlsZSAoKytjb2x1bW5JbmRleCA8IGNvbHVtbkxlbmd0aCkge1xuICAgICAgY2VsbCA9IHJvd1tjb2x1bW5JbmRleF0gfHwgJydcbiAgICAgIGJlZm9yZSA9ICcnXG4gICAgICBhZnRlciA9ICcnXG5cbiAgICAgIGlmIChhbGlnbkRlbGltaXRlcnMgPT09IHRydWUpIHtcbiAgICAgICAgc2l6ZSA9IGxvbmdlc3RDZWxsQnlDb2x1bW5bY29sdW1uSW5kZXhdIC0gKHNpemVzW2NvbHVtbkluZGV4XSB8fCAwKVxuICAgICAgICBjb2RlID0gYWxpZ25tZW50c1tjb2x1bW5JbmRleF1cblxuICAgICAgICBpZiAoY29kZSA9PT0gcikge1xuICAgICAgICAgIGJlZm9yZSA9IHJlcGVhdChzcGFjZSwgc2l6ZSlcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlID09PSBjKSB7XG4gICAgICAgICAgaWYgKHNpemUgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBiZWZvcmUgPSByZXBlYXQoc3BhY2UsIHNpemUgLyAyKVxuICAgICAgICAgICAgYWZ0ZXIgPSBiZWZvcmVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmVmb3JlID0gcmVwZWF0KHNwYWNlLCBzaXplIC8gMiArIDAuNSlcbiAgICAgICAgICAgIGFmdGVyID0gcmVwZWF0KHNwYWNlLCBzaXplIC8gMiAtIDAuNSlcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWZ0ZXIgPSByZXBlYXQoc3BhY2UsIHNpemUpXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YXJ0ID09PSB0cnVlICYmIGNvbHVtbkluZGV4ID09PSAwKSB7XG4gICAgICAgIGxpbmUucHVzaCh2ZXJ0aWNhbEJhcilcbiAgICAgIH1cblxuICAgICAgaWYgKFxuICAgICAgICBwYWRkaW5nID09PSB0cnVlICYmXG4gICAgICAgIC8vIERvbuKAmXQgYWRkIHRoZSBvcGVuaW5nIHNwYWNlIGlmIHdl4oCZcmUgbm90IGFsaWduaW5nIGFuZCB0aGUgY2VsbCBpc1xuICAgICAgICAvLyBlbXB0eTogdGhlcmUgd2lsbCBiZSBhIGNsb3Npbmcgc3BhY2UuXG4gICAgICAgICEoYWxpZ25EZWxpbWl0ZXJzID09PSBmYWxzZSAmJiBjZWxsID09PSAnJykgJiZcbiAgICAgICAgKHN0YXJ0ID09PSB0cnVlIHx8IGNvbHVtbkluZGV4ICE9PSAwKVxuICAgICAgKSB7XG4gICAgICAgIGxpbmUucHVzaChzcGFjZSlcbiAgICAgIH1cblxuICAgICAgaWYgKGFsaWduRGVsaW1pdGVycyA9PT0gdHJ1ZSkge1xuICAgICAgICBsaW5lLnB1c2goYmVmb3JlKVxuICAgICAgfVxuXG4gICAgICBsaW5lLnB1c2goY2VsbClcblxuICAgICAgaWYgKGFsaWduRGVsaW1pdGVycyA9PT0gdHJ1ZSkge1xuICAgICAgICBsaW5lLnB1c2goYWZ0ZXIpXG4gICAgICB9XG5cbiAgICAgIGlmIChwYWRkaW5nID09PSB0cnVlKSB7XG4gICAgICAgIGxpbmUucHVzaChzcGFjZSlcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gdHJ1ZSB8fCBjb2x1bW5JbmRleCAhPT0gY29sdW1uTGVuZ3RoIC0gMSkge1xuICAgICAgICBsaW5lLnB1c2godmVydGljYWxCYXIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgbGluZSA9IGxpbmUuam9pbignJylcblxuICAgIGlmIChlbmQgPT09IGZhbHNlKSB7XG4gICAgICBsaW5lID0gbGluZS5yZXBsYWNlKHRyYWlsaW5nV2hpdGVzcGFjZSwgJycpXG4gICAgfVxuXG4gICAgbGluZXMucHVzaChsaW5lKVxuICB9XG5cbiAgcmV0dXJuIGxpbmVzLmpvaW4obGluZUZlZWQpXG59XG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCA/ICcnIDogU3RyaW5nKHZhbHVlKVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0U3RyaW5nTGVuZ3RoKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZS5sZW5ndGhcbn1cblxuZnVuY3Rpb24gdG9BbGlnbm1lbnQodmFsdWUpIHtcbiAgdmFyIGNvZGUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUuY2hhckNvZGVBdCgwKSA6IHhcblxuICByZXR1cm4gY29kZSA9PT0gTCB8fCBjb2RlID09PSBsXG4gICAgPyBsXG4gICAgOiBjb2RlID09PSBSIHx8IGNvZGUgPT09IHJcbiAgICA/IHJcbiAgICA6IGNvZGUgPT09IEMgfHwgY29kZSA9PT0gY1xuICAgID8gY1xuICAgIDogeFxufVxuIl0sIm5hbWVzIjpbInJlcGVhdCIsInJlcXVpcmUiLCJtb2R1bGUiLCJleHBvcnRzIiwibWFya2Rvd25UYWJsZSIsInRyYWlsaW5nV2hpdGVzcGFjZSIsInNwYWNlIiwibGluZUZlZWQiLCJkYXNoIiwiY29sb24iLCJ2ZXJ0aWNhbEJhciIsIngiLCJDIiwiTCIsIlIiLCJjIiwibCIsInIiLCJ0YWJsZSIsIm9wdGlvbnMiLCJzZXR0aW5ncyIsInBhZGRpbmciLCJzdGFydCIsImRlbGltaXRlclN0YXJ0IiwiZW5kIiwiZGVsaW1pdGVyRW5kIiwiYWxpZ24iLCJjb25jYXQiLCJhbGlnbkRlbGltaXRlcnMiLCJhbGlnbm1lbnRzIiwic3RyaW5nTGVuZ3RoIiwiZGVmYXVsdFN0cmluZ0xlbmd0aCIsInJvd0luZGV4Iiwicm93TGVuZ3RoIiwibGVuZ3RoIiwiY2VsbE1hdHJpeCIsInNpemVNYXRyaXgiLCJyb3ciLCJzaXplcyIsImxvbmdlc3RDZWxsQnlDb2x1bW4iLCJtb3N0Q2VsbHNQZXJSb3ciLCJjZWxscyIsImNvbHVtbkluZGV4IiwiY29sdW1uTGVuZ3RoIiwibGFyZ2VzdCIsInNpemUiLCJjZWxsIiwibGluZXMiLCJsaW5lIiwiYmVmb3JlIiwiYWZ0ZXIiLCJjb2RlIiwic2VyaWFsaXplIiwidW5kZWZpbmVkIiwicHVzaCIsInRvQWxpZ25tZW50IiwiTWF0aCIsIm1heCIsInNwbGljZSIsImpvaW4iLCJyZXBsYWNlIiwidmFsdWUiLCJTdHJpbmciLCJjaGFyQ29kZUF0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/markdown-table/index.js\n");

/***/ })

};
;