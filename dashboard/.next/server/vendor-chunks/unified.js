"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/unified";
exports.ids = ["vendor-chunks/unified"];
exports.modules = {

/***/ "(ssr)/./node_modules/unified/index.js":
/*!***************************************!*\
  !*** ./node_modules/unified/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar bail = __webpack_require__(/*! bail */ \"(ssr)/./node_modules/bail/index.js\");\nvar buffer = __webpack_require__(/*! is-buffer */ \"(ssr)/./node_modules/is-buffer/index.js\");\nvar extend = __webpack_require__(/*! extend */ \"(ssr)/./node_modules/extend/index.js\");\nvar plain = __webpack_require__(/*! is-plain-obj */ \"(ssr)/./node_modules/unified/node_modules/is-plain-obj/index.js\");\nvar trough = __webpack_require__(/*! trough */ \"(ssr)/./node_modules/trough/index.js\");\nvar vfile = __webpack_require__(/*! vfile */ \"(ssr)/./node_modules/vfile/index.js\");\n// Expose a frozen processor.\nmodule.exports = unified().freeze();\nvar slice = [].slice;\nvar own = {}.hasOwnProperty;\n// Process pipeline.\nvar pipeline = trough().use(pipelineParse).use(pipelineRun).use(pipelineStringify);\nfunction pipelineParse(p, ctx) {\n    ctx.tree = p.parse(ctx.file);\n}\nfunction pipelineRun(p, ctx, next) {\n    p.run(ctx.tree, ctx.file, done);\n    function done(error, tree, file) {\n        if (error) {\n            next(error);\n        } else {\n            ctx.tree = tree;\n            ctx.file = file;\n            next();\n        }\n    }\n}\nfunction pipelineStringify(p, ctx) {\n    var result = p.stringify(ctx.tree, ctx.file);\n    if (result === undefined || result === null) {\n    // Empty.\n    } else if (typeof result === \"string\" || buffer(result)) {\n        if (\"value\" in ctx.file) {\n            ctx.file.value = result;\n        }\n        ctx.file.contents = result;\n    } else {\n        ctx.file.result = result;\n    }\n}\n// Function to create the first processor.\nfunction unified() {\n    var attachers = [];\n    var transformers = trough();\n    var namespace = {};\n    var freezeIndex = -1;\n    var frozen;\n    // Data management.\n    processor.data = data;\n    // Lock.\n    processor.freeze = freeze;\n    // Plugins.\n    processor.attachers = attachers;\n    processor.use = use;\n    // API.\n    processor.parse = parse;\n    processor.stringify = stringify;\n    processor.run = run;\n    processor.runSync = runSync;\n    processor.process = process;\n    processor.processSync = processSync;\n    // Expose.\n    return processor;\n    // Create a new processor based on the processor in the current scope.\n    function processor() {\n        var destination = unified();\n        var index = -1;\n        while(++index < attachers.length){\n            destination.use.apply(null, attachers[index]);\n        }\n        destination.data(extend(true, {}, namespace));\n        return destination;\n    }\n    // Freeze: used to signal a processor that has finished configuration.\n    //\n    // For example, take unified itself: it’s frozen.\n    // Plugins should not be added to it.\n    // Rather, it should be extended, by invoking it, before modifying it.\n    //\n    // In essence, always invoke this when exporting a processor.\n    function freeze() {\n        var values;\n        var transformer;\n        if (frozen) {\n            return processor;\n        }\n        while(++freezeIndex < attachers.length){\n            values = attachers[freezeIndex];\n            if (values[1] === false) {\n                continue;\n            }\n            if (values[1] === true) {\n                values[1] = undefined;\n            }\n            transformer = values[0].apply(processor, values.slice(1));\n            if (typeof transformer === \"function\") {\n                transformers.use(transformer);\n            }\n        }\n        frozen = true;\n        freezeIndex = Infinity;\n        return processor;\n    }\n    // Data management.\n    // Getter / setter for processor-specific informtion.\n    function data(key, value) {\n        if (typeof key === \"string\") {\n            // Set `key`.\n            if (arguments.length === 2) {\n                assertUnfrozen(\"data\", frozen);\n                namespace[key] = value;\n                return processor;\n            }\n            // Get `key`.\n            return own.call(namespace, key) && namespace[key] || null;\n        }\n        // Set space.\n        if (key) {\n            assertUnfrozen(\"data\", frozen);\n            namespace = key;\n            return processor;\n        }\n        // Get space.\n        return namespace;\n    }\n    // Plugin management.\n    //\n    // Pass it:\n    // *   an attacher and options,\n    // *   a preset,\n    // *   a list of presets, attachers, and arguments (list of attachers and\n    //     options).\n    function use(value) {\n        var settings;\n        assertUnfrozen(\"use\", frozen);\n        if (value === null || value === undefined) {\n        // Empty.\n        } else if (typeof value === \"function\") {\n            addPlugin.apply(null, arguments);\n        } else if (typeof value === \"object\") {\n            if (\"length\" in value) {\n                addList(value);\n            } else {\n                addPreset(value);\n            }\n        } else {\n            throw new Error(\"Expected usable value, not `\" + value + \"`\");\n        }\n        if (settings) {\n            namespace.settings = extend(namespace.settings || {}, settings);\n        }\n        return processor;\n        function addPreset(result) {\n            addList(result.plugins);\n            if (result.settings) {\n                settings = extend(settings || {}, result.settings);\n            }\n        }\n        function add(value) {\n            if (typeof value === \"function\") {\n                addPlugin(value);\n            } else if (typeof value === \"object\") {\n                if (\"length\" in value) {\n                    addPlugin.apply(null, value);\n                } else {\n                    addPreset(value);\n                }\n            } else {\n                throw new Error(\"Expected usable value, not `\" + value + \"`\");\n            }\n        }\n        function addList(plugins) {\n            var index = -1;\n            if (plugins === null || plugins === undefined) {\n            // Empty.\n            } else if (typeof plugins === \"object\" && \"length\" in plugins) {\n                while(++index < plugins.length){\n                    add(plugins[index]);\n                }\n            } else {\n                throw new Error(\"Expected a list of plugins, not `\" + plugins + \"`\");\n            }\n        }\n        function addPlugin(plugin, value) {\n            var entry = find(plugin);\n            if (entry) {\n                if (plain(entry[1]) && plain(value)) {\n                    value = extend(true, entry[1], value);\n                }\n                entry[1] = value;\n            } else {\n                attachers.push(slice.call(arguments));\n            }\n        }\n    }\n    function find(plugin) {\n        var index = -1;\n        while(++index < attachers.length){\n            if (attachers[index][0] === plugin) {\n                return attachers[index];\n            }\n        }\n    }\n    // Parse a file (in string or vfile representation) into a unist node using\n    // the `Parser` on the processor.\n    function parse(doc) {\n        var file = vfile(doc);\n        var Parser;\n        freeze();\n        Parser = processor.Parser;\n        assertParser(\"parse\", Parser);\n        if (newable(Parser, \"parse\")) {\n            return new Parser(String(file), file).parse();\n        }\n        return Parser(String(file), file) // eslint-disable-line new-cap\n        ;\n    }\n    // Run transforms on a unist node representation of a file (in string or\n    // vfile representation), async.\n    function run(node, file, cb) {\n        assertNode(node);\n        freeze();\n        if (!cb && typeof file === \"function\") {\n            cb = file;\n            file = null;\n        }\n        if (!cb) {\n            return new Promise(executor);\n        }\n        executor(null, cb);\n        function executor(resolve, reject) {\n            transformers.run(node, vfile(file), done);\n            function done(error, tree, file) {\n                tree = tree || node;\n                if (error) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(tree);\n                } else {\n                    cb(null, tree, file);\n                }\n            }\n        }\n    }\n    // Run transforms on a unist node representation of a file (in string or\n    // vfile representation), sync.\n    function runSync(node, file) {\n        var result;\n        var complete;\n        run(node, file, done);\n        assertDone(\"runSync\", \"run\", complete);\n        return result;\n        function done(error, tree) {\n            complete = true;\n            result = tree;\n            bail(error);\n        }\n    }\n    // Stringify a unist node representation of a file (in string or vfile\n    // representation) into a string using the `Compiler` on the processor.\n    function stringify(node, doc) {\n        var file = vfile(doc);\n        var Compiler;\n        freeze();\n        Compiler = processor.Compiler;\n        assertCompiler(\"stringify\", Compiler);\n        assertNode(node);\n        if (newable(Compiler, \"compile\")) {\n            return new Compiler(node, file).compile();\n        }\n        return Compiler(node, file) // eslint-disable-line new-cap\n        ;\n    }\n    // Parse a file (in string or vfile representation) into a unist node using\n    // the `Parser` on the processor, then run transforms on that node, and\n    // compile the resulting node using the `Compiler` on the processor, and\n    // store that result on the vfile.\n    function process(doc, cb) {\n        freeze();\n        assertParser(\"process\", processor.Parser);\n        assertCompiler(\"process\", processor.Compiler);\n        if (!cb) {\n            return new Promise(executor);\n        }\n        executor(null, cb);\n        function executor(resolve, reject) {\n            var file = vfile(doc);\n            pipeline.run(processor, {\n                file: file\n            }, done);\n            function done(error) {\n                if (error) {\n                    reject(error);\n                } else if (resolve) {\n                    resolve(file);\n                } else {\n                    cb(null, file);\n                }\n            }\n        }\n    }\n    // Process the given document (in string or vfile representation), sync.\n    function processSync(doc) {\n        var file;\n        var complete;\n        freeze();\n        assertParser(\"processSync\", processor.Parser);\n        assertCompiler(\"processSync\", processor.Compiler);\n        file = vfile(doc);\n        process(file, done);\n        assertDone(\"processSync\", \"process\", complete);\n        return file;\n        function done(error) {\n            complete = true;\n            bail(error);\n        }\n    }\n}\n// Check if `value` is a constructor.\nfunction newable(value, name) {\n    return typeof value === \"function\" && value.prototype && // A function with keys in its prototype is probably a constructor.\n    // Classes’ prototype methods are not enumerable, so we check if some value\n    // exists in the prototype.\n    (keys(value.prototype) || name in value.prototype);\n}\n// Check if `value` is an object with keys.\nfunction keys(value) {\n    var key;\n    for(key in value){\n        return true;\n    }\n    return false;\n}\n// Assert a parser is available.\nfunction assertParser(name, Parser) {\n    if (typeof Parser !== \"function\") {\n        throw new Error(\"Cannot `\" + name + \"` without `Parser`\");\n    }\n}\n// Assert a compiler is available.\nfunction assertCompiler(name, Compiler) {\n    if (typeof Compiler !== \"function\") {\n        throw new Error(\"Cannot `\" + name + \"` without `Compiler`\");\n    }\n}\n// Assert the processor is not frozen.\nfunction assertUnfrozen(name, frozen) {\n    if (frozen) {\n        throw new Error(\"Cannot invoke `\" + name + \"` on a frozen processor.\\nCreate a new processor first, by invoking it: use `processor()` instead of `processor`.\");\n    }\n}\n// Assert `node` is a unist node.\nfunction assertNode(node) {\n    if (!node || typeof node.type !== \"string\") {\n        throw new Error(\"Expected node, got `\" + node + \"`\");\n    }\n}\n// Assert that `complete` is `true`.\nfunction assertDone(name, asyncName, complete) {\n    if (!complete) {\n        throw new Error(\"`\" + name + \"` finished async. Use `\" + asyncName + \"` instead\");\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0FBQ0EsVUFBVTtRQUNiLE1BQU0sSUFBSW5CLE1BQ1IsTUFBTXdCLE9BQU8sNEJBQTRCSSxZQUFZO0lBRXpEO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9pbmRleC5qcz82YWU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG52YXIgYmFpbCA9IHJlcXVpcmUoJ2JhaWwnKVxudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgnZXh0ZW5kJylcbnZhciBwbGFpbiA9IHJlcXVpcmUoJ2lzLXBsYWluLW9iaicpXG52YXIgdHJvdWdoID0gcmVxdWlyZSgndHJvdWdoJylcbnZhciB2ZmlsZSA9IHJlcXVpcmUoJ3ZmaWxlJylcblxuLy8gRXhwb3NlIGEgZnJvemVuIHByb2Nlc3Nvci5cbm1vZHVsZS5leHBvcnRzID0gdW5pZmllZCgpLmZyZWV6ZSgpXG5cbnZhciBzbGljZSA9IFtdLnNsaWNlXG52YXIgb3duID0ge30uaGFzT3duUHJvcGVydHlcblxuLy8gUHJvY2VzcyBwaXBlbGluZS5cbnZhciBwaXBlbGluZSA9IHRyb3VnaCgpXG4gIC51c2UocGlwZWxpbmVQYXJzZSlcbiAgLnVzZShwaXBlbGluZVJ1bilcbiAgLnVzZShwaXBlbGluZVN0cmluZ2lmeSlcblxuZnVuY3Rpb24gcGlwZWxpbmVQYXJzZShwLCBjdHgpIHtcbiAgY3R4LnRyZWUgPSBwLnBhcnNlKGN0eC5maWxlKVxufVxuXG5mdW5jdGlvbiBwaXBlbGluZVJ1bihwLCBjdHgsIG5leHQpIHtcbiAgcC5ydW4oY3R4LnRyZWUsIGN0eC5maWxlLCBkb25lKVxuXG4gIGZ1bmN0aW9uIGRvbmUoZXJyb3IsIHRyZWUsIGZpbGUpIHtcbiAgICBpZiAoZXJyb3IpIHtcbiAgICAgIG5leHQoZXJyb3IpXG4gICAgfSBlbHNlIHtcbiAgICAgIGN0eC50cmVlID0gdHJlZVxuICAgICAgY3R4LmZpbGUgPSBmaWxlXG4gICAgICBuZXh0KClcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcGlwZWxpbmVTdHJpbmdpZnkocCwgY3R4KSB7XG4gIHZhciByZXN1bHQgPSBwLnN0cmluZ2lmeShjdHgudHJlZSwgY3R4LmZpbGUpXG5cbiAgaWYgKHJlc3VsdCA9PT0gdW5kZWZpbmVkIHx8IHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIC8vIEVtcHR5LlxuICB9IGVsc2UgaWYgKHR5cGVvZiByZXN1bHQgPT09ICdzdHJpbmcnIHx8IGJ1ZmZlcihyZXN1bHQpKSB7XG4gICAgaWYgKCd2YWx1ZScgaW4gY3R4LmZpbGUpIHtcbiAgICAgIGN0eC5maWxlLnZhbHVlID0gcmVzdWx0XG4gICAgfVxuXG4gICAgY3R4LmZpbGUuY29udGVudHMgPSByZXN1bHRcbiAgfSBlbHNlIHtcbiAgICBjdHguZmlsZS5yZXN1bHQgPSByZXN1bHRcbiAgfVxufVxuXG4vLyBGdW5jdGlvbiB0byBjcmVhdGUgdGhlIGZpcnN0IHByb2Nlc3Nvci5cbmZ1bmN0aW9uIHVuaWZpZWQoKSB7XG4gIHZhciBhdHRhY2hlcnMgPSBbXVxuICB2YXIgdHJhbnNmb3JtZXJzID0gdHJvdWdoKClcbiAgdmFyIG5hbWVzcGFjZSA9IHt9XG4gIHZhciBmcmVlemVJbmRleCA9IC0xXG4gIHZhciBmcm96ZW5cblxuICAvLyBEYXRhIG1hbmFnZW1lbnQuXG4gIHByb2Nlc3Nvci5kYXRhID0gZGF0YVxuXG4gIC8vIExvY2suXG4gIHByb2Nlc3Nvci5mcmVlemUgPSBmcmVlemVcblxuICAvLyBQbHVnaW5zLlxuICBwcm9jZXNzb3IuYXR0YWNoZXJzID0gYXR0YWNoZXJzXG4gIHByb2Nlc3Nvci51c2UgPSB1c2VcblxuICAvLyBBUEkuXG4gIHByb2Nlc3Nvci5wYXJzZSA9IHBhcnNlXG4gIHByb2Nlc3Nvci5zdHJpbmdpZnkgPSBzdHJpbmdpZnlcbiAgcHJvY2Vzc29yLnJ1biA9IHJ1blxuICBwcm9jZXNzb3IucnVuU3luYyA9IHJ1blN5bmNcbiAgcHJvY2Vzc29yLnByb2Nlc3MgPSBwcm9jZXNzXG4gIHByb2Nlc3Nvci5wcm9jZXNzU3luYyA9IHByb2Nlc3NTeW5jXG5cbiAgLy8gRXhwb3NlLlxuICByZXR1cm4gcHJvY2Vzc29yXG5cbiAgLy8gQ3JlYXRlIGEgbmV3IHByb2Nlc3NvciBiYXNlZCBvbiB0aGUgcHJvY2Vzc29yIGluIHRoZSBjdXJyZW50IHNjb3BlLlxuICBmdW5jdGlvbiBwcm9jZXNzb3IoKSB7XG4gICAgdmFyIGRlc3RpbmF0aW9uID0gdW5pZmllZCgpXG4gICAgdmFyIGluZGV4ID0gLTFcblxuICAgIHdoaWxlICgrK2luZGV4IDwgYXR0YWNoZXJzLmxlbmd0aCkge1xuICAgICAgZGVzdGluYXRpb24udXNlLmFwcGx5KG51bGwsIGF0dGFjaGVyc1tpbmRleF0pXG4gICAgfVxuXG4gICAgZGVzdGluYXRpb24uZGF0YShleHRlbmQodHJ1ZSwge30sIG5hbWVzcGFjZSkpXG5cbiAgICByZXR1cm4gZGVzdGluYXRpb25cbiAgfVxuXG4gIC8vIEZyZWV6ZTogdXNlZCB0byBzaWduYWwgYSBwcm9jZXNzb3IgdGhhdCBoYXMgZmluaXNoZWQgY29uZmlndXJhdGlvbi5cbiAgLy9cbiAgLy8gRm9yIGV4YW1wbGUsIHRha2UgdW5pZmllZCBpdHNlbGY6IGl04oCZcyBmcm96ZW4uXG4gIC8vIFBsdWdpbnMgc2hvdWxkIG5vdCBiZSBhZGRlZCB0byBpdC5cbiAgLy8gUmF0aGVyLCBpdCBzaG91bGQgYmUgZXh0ZW5kZWQsIGJ5IGludm9raW5nIGl0LCBiZWZvcmUgbW9kaWZ5aW5nIGl0LlxuICAvL1xuICAvLyBJbiBlc3NlbmNlLCBhbHdheXMgaW52b2tlIHRoaXMgd2hlbiBleHBvcnRpbmcgYSBwcm9jZXNzb3IuXG4gIGZ1bmN0aW9uIGZyZWV6ZSgpIHtcbiAgICB2YXIgdmFsdWVzXG4gICAgdmFyIHRyYW5zZm9ybWVyXG5cbiAgICBpZiAoZnJvemVuKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzc29yXG4gICAgfVxuXG4gICAgd2hpbGUgKCsrZnJlZXplSW5kZXggPCBhdHRhY2hlcnMubGVuZ3RoKSB7XG4gICAgICB2YWx1ZXMgPSBhdHRhY2hlcnNbZnJlZXplSW5kZXhdXG5cbiAgICAgIGlmICh2YWx1ZXNbMV0gPT09IGZhbHNlKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIGlmICh2YWx1ZXNbMV0gPT09IHRydWUpIHtcbiAgICAgICAgdmFsdWVzWzFdID0gdW5kZWZpbmVkXG4gICAgICB9XG5cbiAgICAgIHRyYW5zZm9ybWVyID0gdmFsdWVzWzBdLmFwcGx5KHByb2Nlc3NvciwgdmFsdWVzLnNsaWNlKDEpKVxuXG4gICAgICBpZiAodHlwZW9mIHRyYW5zZm9ybWVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRyYW5zZm9ybWVycy51c2UodHJhbnNmb3JtZXIpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnJvemVuID0gdHJ1ZVxuICAgIGZyZWV6ZUluZGV4ID0gSW5maW5pdHlcblxuICAgIHJldHVybiBwcm9jZXNzb3JcbiAgfVxuXG4gIC8vIERhdGEgbWFuYWdlbWVudC5cbiAgLy8gR2V0dGVyIC8gc2V0dGVyIGZvciBwcm9jZXNzb3Itc3BlY2lmaWMgaW5mb3JtdGlvbi5cbiAgZnVuY3Rpb24gZGF0YShrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBTZXQgYGtleWAuXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMikge1xuICAgICAgICBhc3NlcnRVbmZyb3plbignZGF0YScsIGZyb3plbilcbiAgICAgICAgbmFtZXNwYWNlW2tleV0gPSB2YWx1ZVxuICAgICAgICByZXR1cm4gcHJvY2Vzc29yXG4gICAgICB9XG5cbiAgICAgIC8vIEdldCBga2V5YC5cbiAgICAgIHJldHVybiAob3duLmNhbGwobmFtZXNwYWNlLCBrZXkpICYmIG5hbWVzcGFjZVtrZXldKSB8fCBudWxsXG4gICAgfVxuXG4gICAgLy8gU2V0IHNwYWNlLlxuICAgIGlmIChrZXkpIHtcbiAgICAgIGFzc2VydFVuZnJvemVuKCdkYXRhJywgZnJvemVuKVxuICAgICAgbmFtZXNwYWNlID0ga2V5XG4gICAgICByZXR1cm4gcHJvY2Vzc29yXG4gICAgfVxuXG4gICAgLy8gR2V0IHNwYWNlLlxuICAgIHJldHVybiBuYW1lc3BhY2VcbiAgfVxuXG4gIC8vIFBsdWdpbiBtYW5hZ2VtZW50LlxuICAvL1xuICAvLyBQYXNzIGl0OlxuICAvLyAqICAgYW4gYXR0YWNoZXIgYW5kIG9wdGlvbnMsXG4gIC8vICogICBhIHByZXNldCxcbiAgLy8gKiAgIGEgbGlzdCBvZiBwcmVzZXRzLCBhdHRhY2hlcnMsIGFuZCBhcmd1bWVudHMgKGxpc3Qgb2YgYXR0YWNoZXJzIGFuZFxuICAvLyAgICAgb3B0aW9ucykuXG4gIGZ1bmN0aW9uIHVzZSh2YWx1ZSkge1xuICAgIHZhciBzZXR0aW5nc1xuXG4gICAgYXNzZXJ0VW5mcm96ZW4oJ3VzZScsIGZyb3plbilcblxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFbXB0eS5cbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkUGx1Z2luLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmICgnbGVuZ3RoJyBpbiB2YWx1ZSkge1xuICAgICAgICBhZGRMaXN0KHZhbHVlKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWRkUHJlc2V0KHZhbHVlKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHVzYWJsZSB2YWx1ZSwgbm90IGAnICsgdmFsdWUgKyAnYCcpXG4gICAgfVxuXG4gICAgaWYgKHNldHRpbmdzKSB7XG4gICAgICBuYW1lc3BhY2Uuc2V0dGluZ3MgPSBleHRlbmQobmFtZXNwYWNlLnNldHRpbmdzIHx8IHt9LCBzZXR0aW5ncylcbiAgICB9XG5cbiAgICByZXR1cm4gcHJvY2Vzc29yXG5cbiAgICBmdW5jdGlvbiBhZGRQcmVzZXQocmVzdWx0KSB7XG4gICAgICBhZGRMaXN0KHJlc3VsdC5wbHVnaW5zKVxuXG4gICAgICBpZiAocmVzdWx0LnNldHRpbmdzKSB7XG4gICAgICAgIHNldHRpbmdzID0gZXh0ZW5kKHNldHRpbmdzIHx8IHt9LCByZXN1bHQuc2V0dGluZ3MpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkKHZhbHVlKSB7XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGFkZFBsdWdpbih2YWx1ZSlcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAoJ2xlbmd0aCcgaW4gdmFsdWUpIHtcbiAgICAgICAgICBhZGRQbHVnaW4uYXBwbHkobnVsbCwgdmFsdWUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkUHJlc2V0KHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIHVzYWJsZSB2YWx1ZSwgbm90IGAnICsgdmFsdWUgKyAnYCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkTGlzdChwbHVnaW5zKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMVxuXG4gICAgICBpZiAocGx1Z2lucyA9PT0gbnVsbCB8fCBwbHVnaW5zID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gRW1wdHkuXG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBwbHVnaW5zID09PSAnb2JqZWN0JyAmJiAnbGVuZ3RoJyBpbiBwbHVnaW5zKSB7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgcGx1Z2lucy5sZW5ndGgpIHtcbiAgICAgICAgICBhZGQocGx1Z2luc1tpbmRleF0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignRXhwZWN0ZWQgYSBsaXN0IG9mIHBsdWdpbnMsIG5vdCBgJyArIHBsdWdpbnMgKyAnYCcpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWRkUGx1Z2luKHBsdWdpbiwgdmFsdWUpIHtcbiAgICAgIHZhciBlbnRyeSA9IGZpbmQocGx1Z2luKVxuXG4gICAgICBpZiAoZW50cnkpIHtcbiAgICAgICAgaWYgKHBsYWluKGVudHJ5WzFdKSAmJiBwbGFpbih2YWx1ZSkpIHtcbiAgICAgICAgICB2YWx1ZSA9IGV4dGVuZCh0cnVlLCBlbnRyeVsxXSwgdmFsdWUpXG4gICAgICAgIH1cblxuICAgICAgICBlbnRyeVsxXSA9IHZhbHVlXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhdHRhY2hlcnMucHVzaChzbGljZS5jYWxsKGFyZ3VtZW50cykpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZChwbHVnaW4pIHtcbiAgICB2YXIgaW5kZXggPSAtMVxuXG4gICAgd2hpbGUgKCsraW5kZXggPCBhdHRhY2hlcnMubGVuZ3RoKSB7XG4gICAgICBpZiAoYXR0YWNoZXJzW2luZGV4XVswXSA9PT0gcGx1Z2luKSB7XG4gICAgICAgIHJldHVybiBhdHRhY2hlcnNbaW5kZXhdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUGFyc2UgYSBmaWxlIChpbiBzdHJpbmcgb3IgdmZpbGUgcmVwcmVzZW50YXRpb24pIGludG8gYSB1bmlzdCBub2RlIHVzaW5nXG4gIC8vIHRoZSBgUGFyc2VyYCBvbiB0aGUgcHJvY2Vzc29yLlxuICBmdW5jdGlvbiBwYXJzZShkb2MpIHtcbiAgICB2YXIgZmlsZSA9IHZmaWxlKGRvYylcbiAgICB2YXIgUGFyc2VyXG5cbiAgICBmcmVlemUoKVxuICAgIFBhcnNlciA9IHByb2Nlc3Nvci5QYXJzZXJcbiAgICBhc3NlcnRQYXJzZXIoJ3BhcnNlJywgUGFyc2VyKVxuXG4gICAgaWYgKG5ld2FibGUoUGFyc2VyLCAncGFyc2UnKSkge1xuICAgICAgcmV0dXJuIG5ldyBQYXJzZXIoU3RyaW5nKGZpbGUpLCBmaWxlKS5wYXJzZSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIFBhcnNlcihTdHJpbmcoZmlsZSksIGZpbGUpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbmV3LWNhcFxuICB9XG5cbiAgLy8gUnVuIHRyYW5zZm9ybXMgb24gYSB1bmlzdCBub2RlIHJlcHJlc2VudGF0aW9uIG9mIGEgZmlsZSAoaW4gc3RyaW5nIG9yXG4gIC8vIHZmaWxlIHJlcHJlc2VudGF0aW9uKSwgYXN5bmMuXG4gIGZ1bmN0aW9uIHJ1bihub2RlLCBmaWxlLCBjYikge1xuICAgIGFzc2VydE5vZGUobm9kZSlcbiAgICBmcmVlemUoKVxuXG4gICAgaWYgKCFjYiAmJiB0eXBlb2YgZmlsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBmaWxlXG4gICAgICBmaWxlID0gbnVsbFxuICAgIH1cblxuICAgIGlmICghY2IpIHtcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShleGVjdXRvcilcbiAgICB9XG5cbiAgICBleGVjdXRvcihudWxsLCBjYilcblxuICAgIGZ1bmN0aW9uIGV4ZWN1dG9yKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdHJhbnNmb3JtZXJzLnJ1bihub2RlLCB2ZmlsZShmaWxlKSwgZG9uZSlcblxuICAgICAgZnVuY3Rpb24gZG9uZShlcnJvciwgdHJlZSwgZmlsZSkge1xuICAgICAgICB0cmVlID0gdHJlZSB8fCBub2RlXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIHJlamVjdChlcnJvcilcbiAgICAgICAgfSBlbHNlIGlmIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZSh0cmVlKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNiKG51bGwsIHRyZWUsIGZpbGUpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvLyBSdW4gdHJhbnNmb3JtcyBvbiBhIHVuaXN0IG5vZGUgcmVwcmVzZW50YXRpb24gb2YgYSBmaWxlIChpbiBzdHJpbmcgb3JcbiAgLy8gdmZpbGUgcmVwcmVzZW50YXRpb24pLCBzeW5jLlxuICBmdW5jdGlvbiBydW5TeW5jKG5vZGUsIGZpbGUpIHtcbiAgICB2YXIgcmVzdWx0XG4gICAgdmFyIGNvbXBsZXRlXG5cbiAgICBydW4obm9kZSwgZmlsZSwgZG9uZSlcblxuICAgIGFzc2VydERvbmUoJ3J1blN5bmMnLCAncnVuJywgY29tcGxldGUpXG5cbiAgICByZXR1cm4gcmVzdWx0XG5cbiAgICBmdW5jdGlvbiBkb25lKGVycm9yLCB0cmVlKSB7XG4gICAgICBjb21wbGV0ZSA9IHRydWVcbiAgICAgIHJlc3VsdCA9IHRyZWVcbiAgICAgIGJhaWwoZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gU3RyaW5naWZ5IGEgdW5pc3Qgbm9kZSByZXByZXNlbnRhdGlvbiBvZiBhIGZpbGUgKGluIHN0cmluZyBvciB2ZmlsZVxuICAvLyByZXByZXNlbnRhdGlvbikgaW50byBhIHN0cmluZyB1c2luZyB0aGUgYENvbXBpbGVyYCBvbiB0aGUgcHJvY2Vzc29yLlxuICBmdW5jdGlvbiBzdHJpbmdpZnkobm9kZSwgZG9jKSB7XG4gICAgdmFyIGZpbGUgPSB2ZmlsZShkb2MpXG4gICAgdmFyIENvbXBpbGVyXG5cbiAgICBmcmVlemUoKVxuICAgIENvbXBpbGVyID0gcHJvY2Vzc29yLkNvbXBpbGVyXG4gICAgYXNzZXJ0Q29tcGlsZXIoJ3N0cmluZ2lmeScsIENvbXBpbGVyKVxuICAgIGFzc2VydE5vZGUobm9kZSlcblxuICAgIGlmIChuZXdhYmxlKENvbXBpbGVyLCAnY29tcGlsZScpKSB7XG4gICAgICByZXR1cm4gbmV3IENvbXBpbGVyKG5vZGUsIGZpbGUpLmNvbXBpbGUoKVxuICAgIH1cblxuICAgIHJldHVybiBDb21waWxlcihub2RlLCBmaWxlKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5ldy1jYXBcbiAgfVxuXG4gIC8vIFBhcnNlIGEgZmlsZSAoaW4gc3RyaW5nIG9yIHZmaWxlIHJlcHJlc2VudGF0aW9uKSBpbnRvIGEgdW5pc3Qgbm9kZSB1c2luZ1xuICAvLyB0aGUgYFBhcnNlcmAgb24gdGhlIHByb2Nlc3NvciwgdGhlbiBydW4gdHJhbnNmb3JtcyBvbiB0aGF0IG5vZGUsIGFuZFxuICAvLyBjb21waWxlIHRoZSByZXN1bHRpbmcgbm9kZSB1c2luZyB0aGUgYENvbXBpbGVyYCBvbiB0aGUgcHJvY2Vzc29yLCBhbmRcbiAgLy8gc3RvcmUgdGhhdCByZXN1bHQgb24gdGhlIHZmaWxlLlxuICBmdW5jdGlvbiBwcm9jZXNzKGRvYywgY2IpIHtcbiAgICBmcmVlemUoKVxuICAgIGFzc2VydFBhcnNlcigncHJvY2VzcycsIHByb2Nlc3Nvci5QYXJzZXIpXG4gICAgYXNzZXJ0Q29tcGlsZXIoJ3Byb2Nlc3MnLCBwcm9jZXNzb3IuQ29tcGlsZXIpXG5cbiAgICBpZiAoIWNiKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZXhlY3V0b3IpXG4gICAgfVxuXG4gICAgZXhlY3V0b3IobnVsbCwgY2IpXG5cbiAgICBmdW5jdGlvbiBleGVjdXRvcihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBmaWxlID0gdmZpbGUoZG9jKVxuXG4gICAgICBwaXBlbGluZS5ydW4ocHJvY2Vzc29yLCB7ZmlsZTogZmlsZX0sIGRvbmUpXG5cbiAgICAgIGZ1bmN0aW9uIGRvbmUoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgcmVqZWN0KGVycm9yKVxuICAgICAgICB9IGVsc2UgaWYgKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKGZpbGUpXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2IobnVsbCwgZmlsZSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFByb2Nlc3MgdGhlIGdpdmVuIGRvY3VtZW50IChpbiBzdHJpbmcgb3IgdmZpbGUgcmVwcmVzZW50YXRpb24pLCBzeW5jLlxuICBmdW5jdGlvbiBwcm9jZXNzU3luYyhkb2MpIHtcbiAgICB2YXIgZmlsZVxuICAgIHZhciBjb21wbGV0ZVxuXG4gICAgZnJlZXplKClcbiAgICBhc3NlcnRQYXJzZXIoJ3Byb2Nlc3NTeW5jJywgcHJvY2Vzc29yLlBhcnNlcilcbiAgICBhc3NlcnRDb21waWxlcigncHJvY2Vzc1N5bmMnLCBwcm9jZXNzb3IuQ29tcGlsZXIpXG4gICAgZmlsZSA9IHZmaWxlKGRvYylcblxuICAgIHByb2Nlc3MoZmlsZSwgZG9uZSlcblxuICAgIGFzc2VydERvbmUoJ3Byb2Nlc3NTeW5jJywgJ3Byb2Nlc3MnLCBjb21wbGV0ZSlcblxuICAgIHJldHVybiBmaWxlXG5cbiAgICBmdW5jdGlvbiBkb25lKGVycm9yKSB7XG4gICAgICBjb21wbGV0ZSA9IHRydWVcbiAgICAgIGJhaWwoZXJyb3IpXG4gICAgfVxuICB9XG59XG5cbi8vIENoZWNrIGlmIGB2YWx1ZWAgaXMgYSBjb25zdHJ1Y3Rvci5cbmZ1bmN0aW9uIG5ld2FibGUodmFsdWUsIG5hbWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicgJiZcbiAgICB2YWx1ZS5wcm90b3R5cGUgJiZcbiAgICAvLyBBIGZ1bmN0aW9uIHdpdGgga2V5cyBpbiBpdHMgcHJvdG90eXBlIGlzIHByb2JhYmx5IGEgY29uc3RydWN0b3IuXG4gICAgLy8gQ2xhc3Nlc+KAmSBwcm90b3R5cGUgbWV0aG9kcyBhcmUgbm90IGVudW1lcmFibGUsIHNvIHdlIGNoZWNrIGlmIHNvbWUgdmFsdWVcbiAgICAvLyBleGlzdHMgaW4gdGhlIHByb3RvdHlwZS5cbiAgICAoa2V5cyh2YWx1ZS5wcm90b3R5cGUpIHx8IG5hbWUgaW4gdmFsdWUucHJvdG90eXBlKVxuICApXG59XG5cbi8vIENoZWNrIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IHdpdGgga2V5cy5cbmZ1bmN0aW9uIGtleXModmFsdWUpIHtcbiAgdmFyIGtleVxuICBmb3IgKGtleSBpbiB2YWx1ZSkge1xuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLy8gQXNzZXJ0IGEgcGFyc2VyIGlzIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIGFzc2VydFBhcnNlcihuYW1lLCBQYXJzZXIpIHtcbiAgaWYgKHR5cGVvZiBQYXJzZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBgJyArIG5hbWUgKyAnYCB3aXRob3V0IGBQYXJzZXJgJylcbiAgfVxufVxuXG4vLyBBc3NlcnQgYSBjb21waWxlciBpcyBhdmFpbGFibGUuXG5mdW5jdGlvbiBhc3NlcnRDb21waWxlcihuYW1lLCBDb21waWxlcikge1xuICBpZiAodHlwZW9mIENvbXBpbGVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgYCcgKyBuYW1lICsgJ2Agd2l0aG91dCBgQ29tcGlsZXJgJylcbiAgfVxufVxuXG4vLyBBc3NlcnQgdGhlIHByb2Nlc3NvciBpcyBub3QgZnJvemVuLlxuZnVuY3Rpb24gYXNzZXJ0VW5mcm96ZW4obmFtZSwgZnJvemVuKSB7XG4gIGlmIChmcm96ZW4pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQ2Fubm90IGludm9rZSBgJyArXG4gICAgICAgIG5hbWUgK1xuICAgICAgICAnYCBvbiBhIGZyb3plbiBwcm9jZXNzb3IuXFxuQ3JlYXRlIGEgbmV3IHByb2Nlc3NvciBmaXJzdCwgYnkgaW52b2tpbmcgaXQ6IHVzZSBgcHJvY2Vzc29yKClgIGluc3RlYWQgb2YgYHByb2Nlc3NvcmAuJ1xuICAgIClcbiAgfVxufVxuXG4vLyBBc3NlcnQgYG5vZGVgIGlzIGEgdW5pc3Qgbm9kZS5cbmZ1bmN0aW9uIGFzc2VydE5vZGUobm9kZSkge1xuICBpZiAoIW5vZGUgfHwgdHlwZW9mIG5vZGUudHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4cGVjdGVkIG5vZGUsIGdvdCBgJyArIG5vZGUgKyAnYCcpXG4gIH1cbn1cblxuLy8gQXNzZXJ0IHRoYXQgYGNvbXBsZXRlYCBpcyBgdHJ1ZWAuXG5mdW5jdGlvbiBhc3NlcnREb25lKG5hbWUsIGFzeW5jTmFtZSwgY29tcGxldGUpIHtcbiAgaWYgKCFjb21wbGV0ZSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdgJyArIG5hbWUgKyAnYCBmaW5pc2hlZCBhc3luYy4gVXNlIGAnICsgYXN5bmNOYW1lICsgJ2AgaW5zdGVhZCdcbiAgICApXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJiYWlsIiwicmVxdWlyZSIsImJ1ZmZlciIsImV4dGVuZCIsInBsYWluIiwidHJvdWdoIiwidmZpbGUiLCJtb2R1bGUiLCJleHBvcnRzIiwidW5pZmllZCIsImZyZWV6ZSIsInNsaWNlIiwib3duIiwiaGFzT3duUHJvcGVydHkiLCJwaXBlbGluZSIsInVzZSIsInBpcGVsaW5lUGFyc2UiLCJwaXBlbGluZVJ1biIsInBpcGVsaW5lU3RyaW5naWZ5IiwicCIsImN0eCIsInRyZWUiLCJwYXJzZSIsImZpbGUiLCJuZXh0IiwicnVuIiwiZG9uZSIsImVycm9yIiwicmVzdWx0Iiwic3RyaW5naWZ5IiwidW5kZWZpbmVkIiwidmFsdWUiLCJjb250ZW50cyIsImF0dGFjaGVycyIsInRyYW5zZm9ybWVycyIsIm5hbWVzcGFjZSIsImZyZWV6ZUluZGV4IiwiZnJvemVuIiwicHJvY2Vzc29yIiwiZGF0YSIsInJ1blN5bmMiLCJwcm9jZXNzIiwicHJvY2Vzc1N5bmMiLCJkZXN0aW5hdGlvbiIsImluZGV4IiwibGVuZ3RoIiwiYXBwbHkiLCJ2YWx1ZXMiLCJ0cmFuc2Zvcm1lciIsIkluZmluaXR5Iiwia2V5IiwiYXJndW1lbnRzIiwiYXNzZXJ0VW5mcm96ZW4iLCJjYWxsIiwic2V0dGluZ3MiLCJhZGRQbHVnaW4iLCJhZGRMaXN0IiwiYWRkUHJlc2V0IiwiRXJyb3IiLCJwbHVnaW5zIiwiYWRkIiwicGx1Z2luIiwiZW50cnkiLCJmaW5kIiwicHVzaCIsImRvYyIsIlBhcnNlciIsImFzc2VydFBhcnNlciIsIm5ld2FibGUiLCJTdHJpbmciLCJub2RlIiwiY2IiLCJhc3NlcnROb2RlIiwiUHJvbWlzZSIsImV4ZWN1dG9yIiwicmVzb2x2ZSIsInJlamVjdCIsImNvbXBsZXRlIiwiYXNzZXJ0RG9uZSIsIkNvbXBpbGVyIiwiYXNzZXJ0Q29tcGlsZXIiLCJjb21waWxlIiwibmFtZSIsInByb3RvdHlwZSIsImtleXMiLCJ0eXBlIiwiYXN5bmNOYW1lIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unified/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/unified/node_modules/is-plain-obj/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/unified/node_modules/is-plain-obj/index.js ***!
  \*****************************************************************/
/***/ ((module) => {

eval("\nmodule.exports = (value)=>{\n    if (Object.prototype.toString.call(value) !== \"[object Object]\") {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.prototype;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUFBLE9BQU9DLE9BQU8sR0FBR0MsQ0FBQUE7SUFDaEIsSUFBSUMsT0FBT0MsU0FBUyxDQUFDQyxRQUFRLENBQUNDLElBQUksQ0FBQ0osV0FBVyxtQkFBbUI7UUFDaEUsT0FBTztJQUNSO0lBRUEsTUFBTUUsWUFBWUQsT0FBT0ksY0FBYyxDQUFDTDtJQUN4QyxPQUFPRSxjQUFjLFFBQVFBLGNBQWNELE9BQU9DLFNBQVM7QUFDNUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9kYXNoYm9hcmQvLi9ub2RlX21vZHVsZXMvdW5pZmllZC9ub2RlX21vZHVsZXMvaXMtcGxhaW4tb2JqL2luZGV4LmpzPzNlNzYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHZhbHVlID0+IHtcblx0aWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgIT09ICdbb2JqZWN0IE9iamVjdF0nKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Y29uc3QgcHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHZhbHVlKTtcblx0cmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59O1xuIl0sIm5hbWVzIjpbIm1vZHVsZSIsImV4cG9ydHMiLCJ2YWx1ZSIsIk9iamVjdCIsInByb3RvdHlwZSIsInRvU3RyaW5nIiwiY2FsbCIsImdldFByb3RvdHlwZU9mIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/unified/node_modules/is-plain-obj/index.js\n");

/***/ })

};
;